{"version":3,"sources":["c:/Users/HP/Desktop/B2B/b2b-portal/node_modules/@ngui/map/dist/@ngui/map.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;AAaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gGA6IC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0RA,gQAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4BD,yCAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2ED,oFAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkCD,oDAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqDD,oKAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAyGD,sPAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2LD,wWAiBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0BD,kFAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiGD,aAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2LD,uHAUC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6DD,qJAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2CD,oIAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiFD,aAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6BD,mGAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiCD,oIAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkBD,mGAOC;;;;;;;;;;;;;;;;;;;;;;;;;;CAiBD,kFAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoED,qKAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoCD,aAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgCD,kFAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuBD,kFAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0DD,qJAOC;;;;;;;;;;;;;;;;;;;;;;;;;;CAiBD,kFAOC;;;;;;;;;;;;;;;;;;;;;;;;;;CAiBD,kFAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4BD,mCAcC","file":"map.js","sourcesContent":["import { Component, Directive, ElementRef, EventEmitter, Inject, Injectable, InjectionToken, Input, NgModule, NgZone, Optional, Output, ViewChild, ViewContainerRef, ViewEncapsulation } from '@angular/core';\nimport { Observable as Observable$1 } from 'rxjs/Observable';\nimport { ReplaySubject as ReplaySubject$1 } from 'rxjs/ReplaySubject';\nimport { first as first$1 } from 'rxjs/operator/first';\nimport { Subject as Subject$1 } from 'rxjs/Subject';\nimport { debounceTime as debounceTime$1 } from 'rxjs/operator/debounceTime';\nimport { CommonModule } from '@angular/common';\n\n/**\n * return json string from json-like string\n * @param {?} str\n * @return {?}\n */\nfunction jsonize(str) {\n    try {\n        return str;\n    }\n    catch (e) {\n        return str\n            .replace(/([\\$\\w]+)\\s*:/g, // wrap keys without double quote\n        function (_, $1) {\n            return '\"' + $1 + '\":';\n        })\n            .replace(/'([^']+)'/g, // replacing single quote to double quote\n        function (_, $1) {\n            return '\"' + $1 + '\"';\n        });\n    }\n}\n/**\n * Returns string to an object by using JSON.parse()\n * @param {?} input\n * @return {?}\n */\nfunction getJSON(input) {\n    if (typeof input === 'string') {\n        const /** @type {?} */ re = /^[\\+\\-]?[0-9\\.]+,[ ]*\\ ?[\\+\\-]?[0-9\\.]+$/; // lat,lng\n        if (input.match(re)) {\n            input = '[' + input + ']';\n        }\n        return JSON.parse(jsonize(input));\n    }\n    else {\n        return input;\n    }\n}\n/**\n * Returns camel-cased from string 'Foo Bar' to 'fooBar'\n * @param {?} str\n * @return {?}\n */\nfunction toCamelCase(str) {\n    return str.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, function (letter, index) {\n        return index === 0 ? letter.toLowerCase() : letter.toUpperCase();\n    }).replace(/\\s+/g, '');\n}\n/**\n * @return {?}\n */\nfunction isMapsApiLoaded() {\n    return typeof google === 'object' && typeof google.maps === 'object';\n}\n/**\n * @param {?} component\n * @param {?} libName\n * @return {?}\n */\nfunction missingLibraryError(component, libName) {\n    return Error(`${component}: library '${libName}' is missing, please ensure to include it in a 'libraries' parameter.\n    Example:\n      NguiMapModule.forRoot({\n        apiUrl: 'https://maps.googleapis.com/maps/api/js?libraries=${libName}'\n      })\n  `);\n}\n\n/**\n * @abstract\n */\nclass BaseMapDirective {\n    /**\n     * @param {?} nguiMapComponent\n     * @param {?} mapObjectName\n     * @param {?} inputs\n     * @param {?} outputs\n     */\n    constructor(nguiMapComponent, mapObjectName, inputs, outputs) {\n        this.nguiMapComponent = nguiMapComponent;\n        this.mapObjectName = mapObjectName;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        // this should be redefined on each childr directive\n        this.initialized$ = new EventEmitter();\n        this._subscriptions = [];\n        this.nguiMap = this.nguiMapComponent['nguiMap'];\n        this.optionBuilder = this.nguiMapComponent['optionBuilder'];\n        // all outputs must be initialized\n        this.outputs.forEach(output => this[output] = new EventEmitter());\n        this.mapObjectName = mapObjectName;\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        if (this.nguiMapComponent.mapIdledOnce) {\n            this.initialize();\n        }\n        else {\n            this.nguiMapComponent.mapReady$.subscribe(map => this.initialize());\n        }\n    }\n    /**\n     * @return {?}\n     */\n    initialize() {\n        this.objectOptions = this.optionBuilder.googlizeAllInputs(this.inputs, this);\n        // will be set after geocoded\n        typeof this.objectOptions.position === 'string' && (delete this.objectOptions.position);\n        typeof this.objectOptions.center === 'string' && (delete this.objectOptions.center);\n        // noinspection TypeScriptUnresolvedFunction\n        if (this.libraryName) {\n            if (!google.maps[this.libraryName]) {\n                throw missingLibraryError(this.mapObjectName, this.libraryName);\n            }\n            this.mapObject = new google.maps[this.libraryName][this.mapObjectName](this.objectOptions);\n        }\n        else {\n            this.mapObject = new google.maps[this.mapObjectName](this.objectOptions);\n        }\n        this.mapObject.setMap(this.nguiMapComponent.map);\n        this.mapObject['mapObjectName'] = this.mapObjectName;\n        this.mapObject['nguiMapComponent'] = this.nguiMapComponent;\n        // set google events listeners and emits to this outputs listeners\n        this.nguiMap.setObjectEvents(this.outputs, this, 'mapObject');\n        this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n        this.initialized$.emit(this.mapObject);\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        this.nguiMap.updateGoogleObject(this.mapObject, changes);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._subscriptions.map(subscription => subscription.unsubscribe());\n        this.nguiMapComponent.removeFromMapObjectGroup(this.mapObjectName, this.mapObject);\n        if (this.mapObject) {\n            this.nguiMap.clearObjectEvents(this.outputs, this, 'mapObject');\n        }\n    }\n}\nBaseMapDirective.propDecorators = {\n    'initialized$': [{ type: Output },],\n};\n\n/**\n * change any object to google object options\n * e.g. [1,2] -> new google.maps.LatLng(1,2);\n */\nclass OptionBuilder {\n    /**\n     * @param {?} definedInputs\n     * @param {?} userInputs\n     * @return {?}\n     */\n    googlizeAllInputs(definedInputs, userInputs) {\n        let /** @type {?} */ options = {};\n        // if options given from user, only take options and ignore other inputs\n        if (userInputs.options) {\n            options = userInputs.options;\n            if (!this.onlyOptionsGiven(definedInputs, userInputs)) {\n                console.error('when \"options\" are used, other options are ignored');\n            }\n        }\n        else {\n            definedInputs.forEach(input => {\n                if (userInputs[input] !== undefined) {\n                    options[input] = this.googlize(userInputs[input], { key: input });\n                }\n            });\n        }\n        return options;\n    }\n    /**\n     * @param {?} inputs\n     * @param {?=} options\n     * @return {?}\n     */\n    googlizeMultiple(inputs, options) {\n        options = options || {};\n        for (let /** @type {?} */ key in inputs) {\n            let /** @type {?} */ val = inputs[key];\n            // (non-strings are fully converted)\n            if (typeof val !== 'string') {\n                options[key] = val;\n            } // sometimes '0' needed to stay as it is\n            else if (!(options['doNotConverStringToNumber'] && val.match(/^[0-9]+$/))) {\n                options[key] = this.googlize(val, { key: key });\n            }\n        } // for(var key in attrs)\n        return options;\n    }\n    /**\n     * @param {?} input\n     * @param {?=} options\n     * @return {?}\n     */\n    googlize(input, options) {\n        options = options || {};\n        let /** @type {?} */ output = input;\n        if (typeof input === 'string') {\n            if (input === 'false') {\n                output = false;\n            }\n            else if (input === '0') {\n                output = 0;\n            }\n            else {\n                output =\n                    // -> googlize -> getJsonParsed -> googlizeMultiple -> googlize until all elements are parsed\n                    this.getJSONParsed(input, options)\n                        /* Foo.Bar(...) -> new google.maps.Foo.Bar(...) */\n                        || this.getAnyMapObject(input)\n                        /*  MapTypeID.HYBRID -> new google.maps.MapTypeID.HYBRID */\n                        || this.getAnyMapConstant(input, options)\n                        /*  2016-06-20 -> new Date('2016-06-20') */\n                        || this.getDateObject(input)\n                        || input;\n            }\n        }\n        if (options['key']) {\n            let /** @type {?} */ key = (options['key']);\n            if (output instanceof Array) {\n                if (key === 'bounds') {\n                    output = new google.maps.LatLngBounds(output[0], output[1]);\n                }\n                else if (key === 'icons') {\n                    output = this.getMapIcons(output);\n                }\n                else if (key === 'position' || key.match(/^geoFallback/)) {\n                    output = this.getLatLng(output);\n                }\n            }\n            else if (output instanceof Object) {\n                if (key === 'icon') {\n                    output = this.getMarkerIcon(output);\n                }\n                else if (key.match(/ControlOptions$/)) {\n                    output = this.getMapControlOption(output);\n                }\n            }\n        }\n        // delete keys only for processing, not used by google\n        delete output['doNotConverStringToNumber'];\n        delete output['key'];\n        return output;\n    }\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n    getLatLng(input) {\n        let /** @type {?} */ output;\n        if (input[0].constructor === Array) {\n            output = ((input)).map((el) => new google.maps.LatLng(el[0], el[1]));\n        }\n        else if (!isNaN(parseFloat(input[0])) && isFinite(input[0])) {\n            output = new google.maps.LatLng(input[0], input[1]);\n        }\n        return output;\n    }\n    /**\n     * @param {?} input\n     * @param {?} options\n     * @return {?}\n     */\n    getJSONParsed(input, options) {\n        let /** @type {?} */ output;\n        try {\n            output = getJSON(input);\n            if (output instanceof Array) {\n                // [{a:1}] : not lat/lng ones\n                if (output[0].constructor !== Object) {\n                    output = this.getLatLng(output);\n                }\n            }\n            else if (output === Object(output)) {\n                // check for nested hashes and convert to Google API options\n                let /** @type {?} */ newOptions = options;\n                newOptions['doNotConverStringToNumber'] = true;\n                output = this.googlizeMultiple(output, newOptions);\n            }\n        }\n        catch (e) {\n        }\n        return output;\n    }\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n    getAnyMapObject(input) {\n        let /** @type {?} */ output;\n        if (input.match(/^[A-Z][a-zA-Z0-9]+\\(.*\\)$/)) {\n            try {\n                output = Function(`return new google.maps.${input};`)();\n            }\n            catch (e) { }\n        }\n        return output;\n    }\n    /**\n     * @param {?} input\n     * @param {?} options\n     * @return {?}\n     */\n    getAnyMapConstant(input, options) {\n        let /** @type {?} */ output;\n        if (input.match(/^([A-Z][a-zA-Z0-9]+)\\.([A-Z]+)$/)) {\n            try {\n                let /** @type {?} */ matches = input.match(/^([A-Z][a-zA-Z0-9]+)\\.([A-Z]+)$/);\n                output = google.maps[matches[1]][matches[2]];\n            }\n            catch (e) { }\n        }\n        else if (input.match(/^[A-Z]+$/)) {\n            try {\n                let /** @type {?} */ capitalizedKey = ((options['key'])).charAt(0).toUpperCase() +\n                    ((options['key'])).slice(1);\n                output = google.maps[capitalizedKey][input];\n            }\n            catch (e) { }\n        }\n        return output;\n    }\n    /**\n     * streetviewControl, panControl, etc, not a general control\n     * @param {?} controlOptions\n     * @return {?}\n     */\n    getMapControlOption(controlOptions) {\n        let /** @type {?} */ newControlOptions = controlOptions;\n        for (let /** @type {?} */ key in newControlOptions) {\n            if (newControlOptions[key]) {\n                let /** @type {?} */ value = newControlOptions[key];\n                if (typeof value === 'string') {\n                    value = ((value)).toUpperCase();\n                }\n                else if (key === 'mapTypeIds') {\n                    value = ((value)).map(function (str) {\n                        if (str.match(/^[A-Z]+$/)) {\n                            return google.maps.MapTypeId[str.toUpperCase()];\n                        }\n                        else {\n                            return str;\n                        }\n                    });\n                }\n                if (key === 'style') {\n                    let /** @type {?} */ objName = key.replace(/Options$/, '') + 'Style';\n                    newControlOptions[key] = google.maps[objName][(value)];\n                }\n                else if (key === 'position') {\n                    newControlOptions[key] = google.maps.ControlPosition[(value)];\n                }\n                else {\n                    newControlOptions[key] = value;\n                }\n            }\n        }\n        return newControlOptions;\n    }\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n    getDateObject(input) {\n        let /** @type {?} */ output;\n        if (input.match(/^(\\d{4}\\-\\d\\d\\-\\d\\d([tT][\\d:\\.]*)?)([zZ]|([+\\-])(\\d\\d):?(\\d\\d))?$/)) {\n            try {\n                output = new Date(input);\n            }\n            catch (e) { }\n        }\n        return output;\n    }\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n    getMapIcons(input) {\n        return input.map(el => {\n            if (el.icon.path.match(/^[A-Z_]+$/)) {\n                el.icon.path = google.maps.SymbolPath[el.icon.path];\n            }\n            return el;\n        });\n    }\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n    getMarkerIcon(input) {\n        let /** @type {?} */ output = input;\n        if (('' + output.path).match(/^[A-Z_]+$/)) {\n            output.path = google.maps.SymbolPath[output.path];\n        }\n        for (let /** @type {?} */ key in output) {\n            let /** @type {?} */ arr = output[key];\n            if (key === 'anchor' || key === 'origin' || key === 'labelOrigin') {\n                output[key] = new google.maps.Point(arr[0], arr[1]);\n            }\n            else if (key === 'size' || key === 'scaledSize') {\n                output[key] = new google.maps.Size(arr[0], arr[1]);\n            }\n        }\n        return output;\n    }\n    /**\n     * @param {?} definedInputs\n     * @param {?} userInputs\n     * @return {?}\n     */\n    onlyOptionsGiven(definedInputs, userInputs) {\n        for (let /** @type {?} */ i = 0; i < definedInputs.length; i++) {\n            let /** @type {?} */ input = definedInputs[i];\n            if (input !== 'options' && typeof userInputs[input] !== 'undefined') {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nOptionBuilder.decorators = [\n    { type: Injectable },\n];\n/**\n * @nocollapse\n */\nOptionBuilder.ctorParameters = () => [];\n\n/**\n *  service for navigator.geolocation methods\n */\nclass NavigatorGeolocation {\n    /**\n     * @param {?=} geoLocationOptions\n     * @return {?}\n     */\n    getCurrentPosition(geoLocationOptions) {\n        geoLocationOptions = geoLocationOptions || { timeout: 5000 };\n        return new Observable$1((responseObserver) => {\n            if (navigator.geolocation) {\n                navigator.geolocation.getCurrentPosition((position) => {\n                    responseObserver.next(position);\n                    responseObserver.complete();\n                }, (evt) => responseObserver.error(evt), geoLocationOptions);\n            }\n            else {\n                responseObserver.error('Browser Geolocation service failed.');\n            }\n        });\n    }\n}\nNavigatorGeolocation.decorators = [\n    { type: Injectable },\n];\n/**\n * @nocollapse\n */\nNavigatorGeolocation.ctorParameters = () => [];\n\nconst NG_MAP_CONFIG_TOKEN = new InjectionToken('NG_MAP_CONFIG_TOKEN');\n\n/**\n * @abstract\n */\nclass NgMapApiLoader {\n    /**\n     * @param {?} config\n     */\n    constructor(config) {\n        this.config = config;\n        this.api$ = first$1.call(new ReplaySubject$1(1));\n        this.config = this.config || { apiUrl: 'https://maps.google.com/maps/api/js' };\n    }\n    /**\n     * @abstract\n     * @return {?}\n     */\n    load() { }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.api$.complete();\n    }\n}\nclass NgMapAsyncCallbackApiLoader extends NgMapApiLoader {\n    /**\n     * @param {?} zone\n     * @param {?} config\n     */\n    constructor(zone, config) {\n        super(config);\n        this.zone = zone;\n    }\n    /**\n     * @return {?}\n     */\n    load() {\n        if (typeof window === 'undefined') {\n            return;\n        }\n        if (isMapsApiLoaded()) {\n            this.api$.next(google.maps);\n        }\n        else if (!document.querySelector('#ngui-map-api')) {\n            ((window))['nguiMapRef'] = ((window))['nguiMapRef'] || [];\n            ((window))['nguiMapRef'].push({ zone: this.zone, componentFn: () => this.api$.next(google.maps) });\n            this.addGoogleMapsApi();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    addGoogleMapsApi() {\n        ((window))['initNguiMap'] = ((window))['initNguiMap'] || function () {\n            ((window))['nguiMapRef'].forEach(nguiMapRef => {\n                nguiMapRef.zone.run(function () { nguiMapRef.componentFn(); });\n            });\n            ((window))['nguiMapRef'].splice(0, ((window))['nguiMapRef'].length);\n        };\n        let /** @type {?} */ script = document.createElement('script');\n        script.id = 'ngui-map-api';\n        // script.src = \"https://maps.google.com/maps/api/js?callback=initNguiMap\";\n        let /** @type {?} */ apiUrl = this.config.apiUrl;\n        apiUrl += apiUrl.indexOf('?') !== -1 ? '&' : '?';\n        script.src = apiUrl + 'callback=initNguiMap';\n        document.querySelector('body').appendChild(script);\n    }\n}\nNgMapAsyncCallbackApiLoader.decorators = [\n    { type: Injectable },\n];\n/**\n * @nocollapse\n */\nNgMapAsyncCallbackApiLoader.ctorParameters = () => [\n    { type: NgZone, },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NG_MAP_CONFIG_TOKEN,] },] },\n];\nclass NgMapAsyncApiLoader extends NgMapApiLoader {\n    /**\n     * @param {?} config\n     */\n    constructor(config) {\n        super(config);\n    }\n    /**\n     * @return {?}\n     */\n    load() {\n        if (typeof window === 'undefined') {\n            return;\n        }\n        if (isMapsApiLoaded()) {\n            this.api$.next(google.maps);\n        }\n        else if (!document.querySelector('#ngui-map-api')) {\n            let /** @type {?} */ script = document.createElement('script');\n            script.id = 'ngui-map-api';\n            script.async = true;\n            script.onload = () => this.api$.next(google.maps);\n            script.src = this.config.apiUrl;\n            document.querySelector('body').appendChild(script);\n        }\n    }\n}\nNgMapAsyncApiLoader.decorators = [\n    { type: Injectable },\n];\n/**\n * @nocollapse\n */\nNgMapAsyncApiLoader.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NG_MAP_CONFIG_TOKEN,] },] },\n];\n\n/**\n *   Provides [defered/promise API](https://docs.angularjs.org/api/ng/service/$q)\n *   service for Google Geocoder service\n */\nclass GeoCoder {\n    /**\n     * @param {?} apiLoader\n     */\n    constructor(apiLoader) {\n        this.apiLoader = apiLoader;\n        this.apiLoaderSubs = [];\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    geocode(options) {\n        return new Observable$1((responseObserver) => {\n            this.apiLoaderSubs.push(this.apiLoader.api$\n                .subscribe(() => this.requestGeocode(options, responseObserver)));\n        });\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.apiLoaderSubs.map(sub => sub.unsubscribe());\n    }\n    /**\n     * @param {?} options\n     * @param {?} observer\n     * @return {?}\n     */\n    requestGeocode(options, observer) {\n        const /** @type {?} */ geocoder = new google.maps.Geocoder();\n        geocoder.geocode(options, function (results, status) {\n            if (status === google.maps.GeocoderStatus.OK) {\n                observer.next(results);\n                observer.complete();\n            }\n            else {\n                observer.error(results);\n            }\n        });\n    }\n}\nGeoCoder.decorators = [\n    { type: Injectable },\n];\n/**\n * @nocollapse\n */\nGeoCoder.ctorParameters = () => [\n    { type: NgMapApiLoader, },\n];\n\n/**\n * collection of map instance-related properties and methods\n */\nclass NguiMap {\n    /**\n     * @param {?} geoCoder\n     * @param {?} optionBuilder\n     * @param {?} zone\n     */\n    constructor(geoCoder, optionBuilder, zone) {\n        this.geoCoder = geoCoder;\n        this.optionBuilder = optionBuilder;\n        this.zone = zone;\n        this.updateGoogleObject = (object, changes) => {\n            let /** @type {?} */ val, /** @type {?} */ currentValue, /** @type {?} */ setMethodName;\n            if (object) {\n                for (let /** @type {?} */ key in changes) {\n                    setMethodName = `set${key.replace(/^[a-z]/, x => x.toUpperCase())}`;\n                    currentValue = changes[key].currentValue;\n                    if (['position', 'center'].indexOf(key) !== -1 && typeof currentValue === 'string') {\n                        // To preserve setMethod name in Observable callback, wrap it as a function, then execute\n                        ((setMethodName) => {\n                            this.geoCoder.geocode({ address: currentValue }).subscribe(results => {\n                                if (typeof object[setMethodName] === 'function') {\n                                    object[setMethodName](results[0].geometry.location);\n                                }\n                                else {\n                                    console.error('Not all options are dynamically updatable according to Googles Maps API V3 documentation.\\n' +\n                                        'Please check Google Maps API documentation, and use \"setOptions\" instead.');\n                                }\n                            });\n                        })(setMethodName);\n                    }\n                    else {\n                        val = this.optionBuilder.googlize(currentValue);\n                        if (typeof object[setMethodName] === 'function') {\n                            object[setMethodName](val);\n                        }\n                        else {\n                            console.error('Not all options are dynamically updatable according to Googles Maps API V3 documentation.\\n' +\n                                'Please check Google Maps API documentation, and use \"setOptions\" instead.');\n                        }\n                    }\n                }\n            }\n        };\n    }\n    /**\n     * @param {?} definedEvents\n     * @param {?} thisObj\n     * @param {?} prefix\n     * @return {?}\n     */\n    setObjectEvents(definedEvents, thisObj, prefix) {\n        definedEvents.forEach(definedEvent => {\n            const /** @type {?} */ eventName = this.getEventName(definedEvent), /** @type {?} */ zone = this.zone;\n            zone.runOutsideAngular(() => {\n                thisObj[prefix].addListener(eventName, function (event) {\n                    let /** @type {?} */ param = event ? event : {};\n                    param.target = this;\n                    zone.run(() => thisObj[definedEvent].emit(param));\n                });\n            });\n        });\n    }\n    /**\n     * @param {?} definedEvents\n     * @param {?} thisObj\n     * @param {?} prefix\n     * @return {?}\n     */\n    clearObjectEvents(definedEvents, thisObj, prefix) {\n        definedEvents.forEach(definedEvent => {\n            const /** @type {?} */ eventName = this.getEventName(definedEvent);\n            this.zone.runOutsideAngular(() => {\n                if (thisObj[prefix]) {\n                    google.maps.event.clearListeners(thisObj[prefix], eventName);\n                }\n            });\n        });\n        if (thisObj[prefix]) {\n            if (thisObj[prefix].setMap) {\n                thisObj[prefix].setMap(null);\n            }\n            delete thisObj[prefix].nguiMapComponent;\n            delete thisObj[prefix];\n        }\n    }\n    /**\n     * @param {?} definedEvent\n     * @return {?}\n     */\n    getEventName(definedEvent) {\n        return definedEvent\n            .replace(/([A-Z])/g, ($1) => `_${$1.toLowerCase()}`) // positionChanged -> position_changed\n            .replace(/^map_/, ''); // map_click -> click  to avoid DOM conflicts\n    }\n}\nNguiMap.decorators = [\n    { type: Injectable },\n];\n/**\n * @nocollapse\n */\nNguiMap.ctorParameters = () => [\n    { type: GeoCoder, },\n    { type: OptionBuilder, },\n    { type: NgZone, },\n];\n\nconst INPUTS$1 = [\n    'backgroundColor', 'center', 'disableDefaultUI', 'disableDoubleClickZoom', 'draggable', 'draggableCursor',\n    'draggingCursor', 'heading', 'keyboardShortcuts', 'mapMaker', 'mapTypeControl', 'mapTypeId', 'maxZoom', 'minZoom',\n    'noClear', 'overviewMapControl', 'panControl', 'panControlOptions', 'rotateControl', 'scaleControl', 'scrollwheel',\n    'streetView', 'styles', 'tilt', 'zoom', 'streetViewControl', 'zoomControl', 'zoomControlOptions', 'mapTypeControlOptions',\n    'overviewMapControlOptions', 'rotateControlOptions', 'scaleControlOptions', 'streetViewControlOptions', 'fullscreenControl', 'fullscreenControlOptions',\n    'options',\n    // ngui-map-specific inputs\n    'geoFallbackCenter'\n];\nconst OUTPUTS$1 = [\n    'bounds_changed', 'center_changed', 'click', 'dblclick', 'drag', 'dragend', 'dragstart', 'heading_changed', 'idle',\n    'typeid_changed', 'mousemove', 'mouseout', 'mouseover', 'projection_changed', 'resize', 'rightclick',\n    'tilesloaded', 'tile_changed', 'zoom_changed',\n    // to avoid DOM event conflicts\n    'mapClick', 'mapMouseover', 'mapMouseout', 'mapMousemove', 'mapDrag', 'mapDragend', 'mapDragstart'\n];\nclass NguiMapComponent {\n    /**\n     * @param {?} optionBuilder\n     * @param {?} elementRef\n     * @param {?} geolocation\n     * @param {?} geoCoder\n     * @param {?} nguiMap\n     * @param {?} apiLoader\n     * @param {?} zone\n     */\n    constructor(optionBuilder, elementRef, geolocation, geoCoder, nguiMap, apiLoader, zone) {\n        this.optionBuilder = optionBuilder;\n        this.elementRef = elementRef;\n        this.geolocation = geolocation;\n        this.geoCoder = geoCoder;\n        this.nguiMap = nguiMap;\n        this.apiLoader = apiLoader;\n        this.zone = zone;\n        this.mapReady$ = new EventEmitter();\n        this.mapOptions = {};\n        this.inputChanges$ = new Subject$1();\n        this.infoWindows = {};\n        this.mapIdledOnce = false;\n        this.initializeMapAfterDisplayed = false;\n        apiLoader.load();\n        // all outputs needs to be initialized,\n        // http://stackoverflow.com/questions/37765519/angular2-directive-cannot-read-property-subscribe-of-undefined-with-outputs\n        OUTPUTS$1.forEach(output => this[output] = new EventEmitter());\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        this.apiLoaderSub = this.apiLoader.api$.subscribe(() => this.initializeMap());\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewChecked() {\n        if (this.initializeMapAfterDisplayed && this.el && this.el.offsetWidth > 0) {\n            this.initializeMap();\n        }\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        this.inputChanges$.next(changes);\n    }\n    /**\n     * @return {?}\n     */\n    initializeMap() {\n        this.el = this.elementRef.nativeElement.querySelector('.google-map');\n        if (this.el && this.el.offsetWidth === 0) {\n            this.initializeMapAfterDisplayed = true;\n            return;\n        }\n        this.initializeMapAfterDisplayed = false;\n        this.mapOptions = this.optionBuilder.googlizeAllInputs(INPUTS$1, this);\n        this.mapOptions.zoom = this.mapOptions.zoom || 15;\n        typeof this.mapOptions.center === 'string' && (delete this.mapOptions.center);\n        this.zone.runOutsideAngular(() => {\n            this.map = new google.maps.Map(this.el, this.mapOptions);\n            this.map['mapObjectName'] = 'NguiMapComponent';\n            if (!this.mapOptions.center) {\n                this.setCenter();\n            }\n            // set google events listeners and emits to this outputs listeners\n            this.nguiMap.setObjectEvents(OUTPUTS$1, this, 'map');\n            this.map.addListener('idle', () => {\n                if (!this.mapIdledOnce) {\n                    this.mapIdledOnce = true;\n                    setTimeout(() => {\n                        this.mapReady$.emit(this.map);\n                    });\n                }\n            });\n            // update map when input changes\n            debounceTime$1.call(this.inputChanges$, 1000)\n                .subscribe((changes) => this.nguiMap.updateGoogleObject(this.map, changes));\n            if (typeof window !== 'undefined' && ((window))['nguiMapRef']) {\n                // expose map object for test and debugging on (<any>window)\n                ((window))['nguiMapRef'].map = this.map;\n            }\n        });\n    }\n    /**\n     * @return {?}\n     */\n    setCenter() {\n        if (!this['center']) {\n            this.geolocation.getCurrentPosition().subscribe(position => {\n                let /** @type {?} */ latLng = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);\n                this.map.setCenter(latLng);\n            }, error => {\n                console.error('ngui-map: Error finding the current position');\n                this.map.setCenter(this.mapOptions['geoFallbackCenter'] || new google.maps.LatLng(0, 0));\n            });\n        }\n        else if (typeof this['center'] === 'string') {\n            this.geoCoder.geocode({ address: this['center'] }).subscribe(results => {\n                this.map.setCenter(results[0].geometry.location);\n            }, error => {\n                this.map.setCenter(this.mapOptions['geoFallbackCenter'] || new google.maps.LatLng(0, 0));\n            });\n        }\n    }\n    /**\n     * @param {?} id\n     * @param {?} anchor\n     * @return {?}\n     */\n    openInfoWindow(id, anchor) {\n        this.infoWindows[id].open(anchor);\n    }\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    closeInfoWindow(id) {\n        // if infoWindow for id exists, close the infoWindow\n        if (this.infoWindows[id])\n            this.infoWindows[id].close();\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.inputChanges$.complete();\n        if (this.el && !this.initializeMapAfterDisplayed) {\n            this.nguiMap.clearObjectEvents(OUTPUTS$1, this, 'map');\n        }\n        if (this.apiLoaderSub) {\n            this.apiLoaderSub.unsubscribe();\n        }\n    }\n    /**\n     * @param {?} mapObjectName\n     * @param {?} mapObject\n     * @return {?}\n     */\n    addToMapObjectGroup(mapObjectName, mapObject) {\n        let /** @type {?} */ groupName = toCamelCase(mapObjectName.toLowerCase()) + 's'; // e.g. markers\n        this.map[groupName] = this.map[groupName] || [];\n        this.map[groupName].push(mapObject);\n    }\n    /**\n     * @param {?} mapObjectName\n     * @param {?} mapObject\n     * @return {?}\n     */\n    removeFromMapObjectGroup(mapObjectName, mapObject) {\n        let /** @type {?} */ groupName = toCamelCase(mapObjectName.toLowerCase()) + 's'; // e.g. markers\n        if (this.map && this.map[groupName]) {\n            let /** @type {?} */ index = this.map[groupName].indexOf(mapObject);\n            (index > -1) && this.map[groupName].splice(index, 1);\n        }\n    }\n}\nNguiMapComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'ngui-map',\n                providers: [NguiMap, OptionBuilder, GeoCoder, NavigatorGeolocation],\n                styles: [`\n    ngui-map {display: block; height: 300px;}\n    .google-map {width: 100%; height: 100%}\n  `],\n                inputs: INPUTS$1,\n                outputs: OUTPUTS$1,\n                encapsulation: ViewEncapsulation.None,\n                template: `\n    <div class=\"google-map\"></div>\n    <ng-content></ng-content>\n  `,\n            },] },\n];\n/**\n * @nocollapse\n */\nNguiMapComponent.ctorParameters = () => [\n    { type: OptionBuilder, },\n    { type: ElementRef, },\n    { type: NavigatorGeolocation, },\n    { type: GeoCoder, },\n    { type: NguiMap, },\n    { type: NgMapApiLoader, },\n    { type: NgZone, },\n];\nNguiMapComponent.propDecorators = {\n    'mapReady$': [{ type: Output },],\n};\n\nconst INPUTS = [];\nconst OUTPUTS = [];\nclass BicyclingLayer extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n        super(nguiMapComp, 'BicyclingLayer', INPUTS, OUTPUTS);\n    }\n}\nBicyclingLayer.decorators = [\n    { type: Directive, args: [{\n                selector: 'ngui-map > bicycling-layer',\n                inputs: INPUTS,\n                outputs: OUTPUTS,\n            },] },\n];\n/**\n * @nocollapse\n */\nBicyclingLayer.ctorParameters = () => [\n    { type: NguiMapComponent, },\n];\n\nconst INPUTS$2 = [\n    'content', 'disableAutoPan', 'maxWidth', 'pixelOffset', 'position', 'zIndex', 'options'\n];\nconst OUTPUTS$2 = [\n    'closeclick', 'content_changed', 'domready', 'position_changed', 'zindex_changed'\n];\nclass InfoWindow {\n    /**\n     * @param {?} elementRef\n     * @param {?} nguiMap\n     * @param {?} nguiMapComponent\n     */\n    constructor(elementRef, nguiMap, nguiMapComponent) {\n        this.elementRef = elementRef;\n        this.nguiMap = nguiMap;\n        this.nguiMapComponent = nguiMapComponent;\n        this.initialized$ = new EventEmitter();\n        this.objectOptions = {};\n        this.inputChanges$ = new Subject$1();\n        this.elementRef.nativeElement.style.display = 'none';\n        OUTPUTS$2.forEach(output => this[output] = new EventEmitter());\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        if (this.nguiMapComponent.mapIdledOnce) {\n            this.initialize();\n        }\n        else {\n            this.nguiMapComponent.mapReady$.subscribe(map => this.initialize());\n        }\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        this.inputChanges$.next(changes);\n    }\n    /**\n     * @return {?}\n     */\n    initialize() {\n        this.objectOptions = this.nguiMapComponent.optionBuilder.googlizeAllInputs(INPUTS$2, this);\n        this.infoWindow = new google.maps.InfoWindow(this.objectOptions);\n        this.infoWindow['mapObjectName'] = 'InfoWindow';\n        // register infoWindow ids to NguiMap, so that it can be opened by id\n        if (this.elementRef.nativeElement.id) {\n            this.nguiMapComponent.infoWindows[this.elementRef.nativeElement.id] = this;\n        }\n        else {\n            console.error('An InfoWindow must have an id. e.g. id=\"detail\"');\n        }\n        // set google events listeners and emits to this outputs listeners\n        this.nguiMap.setObjectEvents(OUTPUTS$2, this, 'infoWindow');\n        // update object when input changes\n        debounceTime$1.call(this.inputChanges$, 1000)\n            .subscribe((changes) => this.nguiMap.updateGoogleObject(this.infoWindow, changes));\n        this.nguiMapComponent.addToMapObjectGroup('InfoWindow', this.infoWindow);\n        this.initialized$.emit(this.infoWindow);\n    }\n    /**\n     * @param {?} anchor\n     * @return {?}\n     */\n    open(anchor) {\n        // set content and open it\n        this.infoWindow.setContent(this.template.element.nativeElement);\n        this.infoWindow.open(this.nguiMapComponent.map, anchor);\n    }\n    /**\n     * @return {?}\n     */\n    close() {\n        // check if infoWindow exists, and closes it\n        if (this.infoWindow)\n            this.infoWindow.close();\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.inputChanges$.complete();\n        if (this.infoWindow) {\n            this.nguiMap.clearObjectEvents(OUTPUTS$2, this, 'infoWindow');\n            delete this.infoWindow;\n        }\n    }\n}\nInfoWindow.decorators = [\n    { type: Component, args: [{\n                selector: 'ngui-map > info-window',\n                inputs: INPUTS$2,\n                outputs: OUTPUTS$2,\n                template: `<div #template><ng-content></ng-content></div>`,\n            },] },\n];\n/**\n * @nocollapse\n */\nInfoWindow.ctorParameters = () => [\n    { type: ElementRef, },\n    { type: NguiMap, },\n    { type: NguiMapComponent, },\n];\nInfoWindow.propDecorators = {\n    'initialized$': [{ type: Output },],\n    'template': [{ type: ViewChild, args: ['template', { read: ViewContainerRef },] },],\n};\n\nconst INPUTS$3 = [\n    'position'\n];\n// to avoid DOM event conflicts map_*\nconst OUTPUTS$3 = [\n    'animationChanged', 'click', 'clickableChanged', 'cursorChanged', 'dblclick', 'drag', 'dragend', 'draggableChanged',\n    'dragstart', 'flatChanged', 'iconChanged', 'mousedown', 'mouseout', 'mouseover', 'mouseup', 'positionChanged', 'rightclick',\n    'shapeChanged', 'titleChanged', 'visibleChanged', 'zindexChanged',\n    'map_click', 'map_mouseover', 'map_mouseout', 'map_mouseup', 'map_mousedown', 'map_drag', 'map_dragend'\n];\n/**\n * Wrapper to a create extend OverlayView at runtime, only after google maps is loaded.\n * Otherwise throws a google is unknown error.\n * @param {?} htmlEl\n * @param {?} position\n * @return {?}\n */\nfunction getCustomMarkerOverlayView(htmlEl, position) {\n    class CustomMarkerOverlayView extends google.maps.OverlayView {\n        /**\n         * @param {?} htmlEl\n         * @param {?} position\n         */\n        constructor(htmlEl, position) {\n            super();\n            this.visible = true;\n            this.setPosition = (position) => {\n                this.htmlEl.style.visibility = 'hidden';\n                if (position.constructor.name === 'Array') {\n                    this.position = new google.maps.LatLng(position[0], position[1]);\n                }\n                else if (typeof position === 'string') {\n                    let /** @type {?} */ geocoder = new google.maps.Geocoder();\n                    geocoder.geocode({ address: position }, (results, status) => {\n                        if (status === google.maps.GeocoderStatus.OK) {\n                            this.setPosition(results[0].geometry.location);\n                        }\n                        else {\n                        }\n                    });\n                }\n                else if (position && typeof position.lng === 'function') {\n                    this.position = position;\n                }\n                if (this.getProjection() && typeof this.position.lng === 'function') {\n                    let /** @type {?} */ positionOnMap = () => {\n                        let /** @type {?} */ projection = this.getProjection();\n                        if (!projection) {\n                            return;\n                        }\n                        let /** @type {?} */ posPixel = projection.fromLatLngToDivPixel(this.position);\n                        let /** @type {?} */ x = Math.round(posPixel.x - (this.htmlEl.offsetWidth / 2));\n                        let /** @type {?} */ y = Math.round(posPixel.y - this.htmlEl.offsetHeight / 2);\n                        this.htmlEl.style.left = x + 'px';\n                        this.htmlEl.style.top = y + 'px';\n                        this.htmlEl.style.visibility = 'visible';\n                    };\n                    if (this.htmlEl.offsetWidth && this.htmlEl.offsetHeight) {\n                        positionOnMap();\n                    }\n                    else {\n                        setTimeout(() => positionOnMap());\n                    }\n                }\n            };\n            this.htmlEl = htmlEl;\n            this.position = position;\n        }\n        /**\n         * @return {?}\n         */\n        onAdd() {\n            this.getPanes().overlayMouseTarget.appendChild(this.htmlEl);\n            // required for correct display inside google maps container\n            this.htmlEl.style.position = 'absolute';\n        }\n        /**\n         * @return {?}\n         */\n        draw() {\n            this.setPosition(this.position);\n            this.setZIndex(this.zIndex);\n            this.setVisible(this.visible);\n        }\n        /**\n         * @return {?}\n         */\n        onRemove() {\n            //\n        }\n        /**\n         * @return {?}\n         */\n        getPosition() {\n            return this.position;\n        }\n        /**\n         * @param {?} zIndex\n         * @return {?}\n         */\n        setZIndex(zIndex) {\n            zIndex && (this.zIndex = zIndex); /* jshint ignore:line */\n            this.htmlEl.style.zIndex = this.zIndex;\n        }\n        /**\n         * @param {?} visible\n         * @return {?}\n         */\n        setVisible(visible) {\n            this.htmlEl.style.display = visible ? 'inline-block' : 'none';\n            this.visible = visible;\n        }\n    }\n    return new CustomMarkerOverlayView(htmlEl, position);\n}\nclass CustomMarker {\n    /**\n     * @param {?} nguiMapComponent\n     * @param {?} elementRef\n     * @param {?} nguiMap\n     */\n    constructor(nguiMapComponent, elementRef, nguiMap) {\n        this.nguiMapComponent = nguiMapComponent;\n        this.elementRef = elementRef;\n        this.nguiMap = nguiMap;\n        this.initialized$ = new EventEmitter();\n        this.inputChanges$ = new Subject$1();\n        this.elementRef.nativeElement.style.display = 'none';\n        OUTPUTS$3.forEach(output => this[output] = new EventEmitter());\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        if (this.nguiMapComponent.mapIdledOnce) {\n            this.initialize();\n        }\n        else {\n            this.nguiMapComponent.mapReady$.subscribe(map => this.initialize());\n        }\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        this.inputChanges$.next(changes);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.inputChanges$.complete();\n        this.nguiMapComponent.removeFromMapObjectGroup('CustomMarker', this.mapObject);\n        if (this.mapObject) {\n            this.nguiMap.clearObjectEvents(OUTPUTS$3, this, 'mapObject');\n        }\n    }\n    /**\n     * @return {?}\n     */\n    initialize() {\n        this.el = this.elementRef.nativeElement;\n        this.mapObject = getCustomMarkerOverlayView(this.el, this['position']);\n        this.mapObject.setMap(this.nguiMapComponent.map);\n        // set google events listeners and emits to this outputs listeners\n        this.nguiMap.setObjectEvents(OUTPUTS$3, this, 'mapObject');\n        // update object when input changes\n        debounceTime$1.call(this.inputChanges$, 1000)\n            .subscribe((changes) => this.nguiMap.updateGoogleObject(this.mapObject, changes));\n        this.nguiMapComponent.addToMapObjectGroup('CustomMarker', this.mapObject);\n        this.initialized$.emit(this.mapObject);\n    }\n}\nCustomMarker.decorators = [\n    { type: Component, args: [{\n                selector: 'ngui-map > custom-marker',\n                inputs: INPUTS$3,\n                outputs: OUTPUTS$3,\n                template: `\n    <ng-content></ng-content>\n  `,\n            },] },\n];\n/**\n * @nocollapse\n */\nCustomMarker.ctorParameters = () => [\n    { type: NguiMapComponent, },\n    { type: ElementRef, },\n    { type: NguiMap, },\n];\nCustomMarker.propDecorators = {\n    'initialized$': [{ type: Output },],\n};\n\nconst INPUTS$4 = [\n    'center', 'clickable', 'draggable', 'editable', 'fillColor', 'fillOpacity', 'map', 'radius',\n    'strokeColor', 'strokeOpacity', 'strokePosition', 'strokeWeight', 'visible', 'zIndex', 'options',\n    // ngui-map specific inputs\n    'geoFallbackCenter'\n];\nconst OUTPUTS$4 = [\n    'centerChanged', 'click', 'dblclick', 'drag', 'dragend', 'dragstart',\n    'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'radiusChanged', 'rightclick',\n];\nclass Circle extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n        super(nguiMapComp, 'Circle', INPUTS$4, OUTPUTS$4);\n        this.nguiMapComp = nguiMapComp;\n        this.objectOptions = ({});\n    }\n    /**\n     * @return {?}\n     */\n    initialize() {\n        super.initialize();\n        this.setCenter();\n    }\n    /**\n     * @return {?}\n     */\n    setCenter() {\n        if (!this['center']) {\n            this._subscriptions.push(this.nguiMapComp.geolocation.getCurrentPosition().subscribe(center => {\n                let /** @type {?} */ latLng = new google.maps.LatLng(center.coords.latitude, center.coords.longitude);\n                this.mapObject.setCenter(latLng);\n            }, error => {\n                console.error('ngui-map, error in finding the current position');\n                this.mapObject.setCenter(this.objectOptions['geoFallbackCenter'] || new google.maps.LatLng(0, 0));\n            }));\n        }\n        else if (typeof this['center'] === 'string') {\n            this._subscriptions.push(this.nguiMapComp.geoCoder.geocode({ address: this['center'] }).subscribe(results => {\n                this.mapObject.setCenter(results[0].geometry.location);\n            }, error => {\n                console.error('ngui-map, error in finding location from', this['center']);\n                this.mapObject.setCenter(this.objectOptions['geoFallbackCenter'] || new google.maps.LatLng(0, 0));\n            }));\n        }\n    }\n}\nCircle.decorators = [\n    { type: Directive, args: [{\n                selector: 'ngui-map>circle, ngui-map>map-circle',\n                inputs: INPUTS$4,\n                outputs: OUTPUTS$4,\n            },] },\n];\n/**\n * @nocollapse\n */\nCircle.ctorParameters = () => [\n    { type: NguiMapComponent, },\n];\n\nconst INPUTS$5 = ['controlPosition', 'controls', 'drawingMode', 'featureFactory', 'style', 'geoJson', 'geoJsonUrl'];\nconst OUTPUTS$5 = [\n    'addfeature', 'click', 'dblclick', 'mousedown', 'mouseout', 'mouseover',\n    'mouseup', 'removefeature', 'removeproperty', 'rightclick', 'setgeometry', 'setproperty'\n];\nclass DataLayer extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComponent\n     */\n    constructor(nguiMapComponent) {\n        super(nguiMapComponent, 'Data', INPUTS$5, OUTPUTS$5);\n    }\n    /**\n     * @return {?}\n     */\n    initialize() {\n        if (this['geoJson']) {\n            // addGeoJson from an object\n            this.nguiMapComponent.map.data.addGeoJson(this['geoJson']);\n        }\n        else if (this['geoJsonUrl']) {\n            // loadGeoJson from a URL\n            this.nguiMapComponent.map.data.loadGeoJson(this['geoJsonUrl']);\n        }\n        else {\n            this.objectOptions = this.optionBuilder.googlizeAllInputs(this.inputs, this);\n            this.nguiMapComponent.map.data.add(this.objectOptions);\n        }\n        // unlike others, data belongs to map. e.g., map.data.loadGeoJson(), map.data.add()\n        this.mapObject = this.nguiMapComponent.map.data;\n        // set google events listeners and emits to this outputs listeners\n        this.nguiMap.setObjectEvents(this.outputs, this, 'mapObject');\n        this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n        this.initialized$.emit(this.mapObject);\n    }\n}\nDataLayer.decorators = [\n    { type: Directive, args: [{\n                selector: 'ngui-map > data-layer',\n                inputs: INPUTS$5,\n                outputs: OUTPUTS$5,\n            },] },\n];\n/**\n * @nocollapse\n */\nDataLayer.ctorParameters = () => [\n    { type: NguiMapComponent, },\n];\n\nconst INPUTS$6 = [\n    'directions', 'draggable', 'hideRouteList', 'infoWindow', 'panel', 'markerOptions',\n    'polylineOptions', 'preserveViewport', 'routeIndex', 'suppressBicyclingLayer',\n    'suppressInfoWindows', 'suppressMarkers', 'suppressPolylines'\n];\nconst OUTPUTS$6 = ['directions_changed'];\nclass DirectionsRenderer extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComponent\n     * @param {?} geolocation\n     */\n    constructor(nguiMapComponent, geolocation) {\n        super(nguiMapComponent, 'DirectionsRenderer', INPUTS$6, OUTPUTS$6);\n        this.geolocation = geolocation;\n    }\n    /**\n     * @return {?}\n     */\n    initialize() {\n        this.objectOptions = this.optionBuilder.googlizeAllInputs(this.inputs, this);\n        if (typeof this.objectOptions['panel'] === 'string') {\n            this.objectOptions['panel'] = document.querySelector(this.objectOptions['panel']);\n        }\n        this.directionsService = new google.maps.DirectionsService();\n        this.directionsRenderer = new google.maps.DirectionsRenderer(this.objectOptions);\n        this.directionsRenderer.setMap(this.nguiMapComponent.map);\n        // set google events listeners and emidirectionsRenderer to this outputs listeners\n        this.showDirections(this.directionsRequest);\n        this.nguiMap.setObjectEvents(this.outputs, this, 'directionsRenderer');\n        this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n        this.initialized$.emit(this.directionsRenderer);\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        let /** @type {?} */ newOptions = {};\n        for (let /** @type {?} */ key in changes) {\n            if (this.inputs.indexOf(key) !== -1) {\n                newOptions[key] = this.optionBuilder.googlize(changes[key].currentValue);\n            }\n        }\n        if (changes['directionsRequest'] && this.directionsRenderer) {\n            this.directionsService && this.showDirections(this.directionsRequest);\n        }\n    }\n    /**\n     * @param {?} directionsRequest\n     * @return {?}\n     */\n    showDirections(directionsRequest) {\n        this.directionsService.route(directionsRequest, (response, status) => {\n            // in some-case the callback is called during destroy component,\n            // we should make sure directionsRenderer is still defined (cancelling `route` callback is not possible).\n            if (!this.directionsRenderer) {\n                return;\n            }\n            if (status === google.maps.DirectionsStatus.OK) {\n                this.directionsRenderer.setDirections(response);\n            }\n            else {\n                console.error('Directions request failed due to ' + status);\n            }\n        });\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        this.nguiMap.clearObjectEvents(this.outputs, this, 'directionsRenderer');\n    }\n}\nDirectionsRenderer.decorators = [\n    { type: Directive, args: [{\n                selector: 'ngui-map > directions-renderer',\n                inputs: INPUTS$6,\n                outputs: OUTPUTS$6,\n            },] },\n];\n/**\n * @nocollapse\n */\nDirectionsRenderer.ctorParameters = () => [\n    { type: NguiMapComponent, },\n    { type: NavigatorGeolocation, },\n];\nDirectionsRenderer.propDecorators = {\n    'directionsRequest': [{ type: Input, args: ['directions-request',] },],\n};\n\nconst INPUTS$7 = [\n    'options',\n    'circleOptions', 'drawingControl', 'drawingControlOptions', 'drawingMode',\n    'map', 'markerOptions', 'polygonOptions', 'polylineOptions', 'rectangleOptions'\n];\nconst OUTPUTS$7 = [\n    'circlecomplete', 'markercomplete', 'overlaycomplete',\n    'polygoncomplete', 'polylinecomplete', 'rectanglecomplete'\n];\nclass DrawingManager extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n        super(nguiMapComp, 'DrawingManager', INPUTS$7, OUTPUTS$7);\n        this.libraryName = 'drawing';\n    }\n}\nDrawingManager.decorators = [\n    { type: Directive, args: [{\n                selector: 'ngui-map > drawing-manager',\n                inputs: INPUTS$7,\n                outputs: OUTPUTS$7,\n            },] },\n];\n/**\n * @nocollapse\n */\nDrawingManager.ctorParameters = () => [\n    { type: NguiMapComponent, },\n];\n\nconst INPUTS$8 = ['url', 'bounds', 'clickable', 'opacity'];\nconst OUTPUTS$8 = ['click', 'dblclick'];\nclass GroundOverlay extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n        super(nguiMapComp, 'GroundOverlay', INPUTS$8, OUTPUTS$8);\n        this.objectOptions = ({});\n    }\n    /**\n     * @return {?}\n     */\n    initialize() {\n        // url, bounds are not the options of GroundOverlay\n        this.objectOptions = this.optionBuilder.googlizeAllInputs(['clickable', 'opacity'], this);\n        // noinspection TypeScriptUnresolvedFunction\n        this.mapObject = new google.maps.GroundOverlay(this['url'], this['bounds'], this.objectOptions);\n        this.mapObject.setMap(this.nguiMapComponent.map);\n        this.mapObject['mapObjectName'] = this.mapObjectName;\n        // set google events listeners and emits to this outputs listeners\n        this.nguiMap.setObjectEvents(this.outputs, this, 'mapObject');\n        this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n        this.initialized$.emit(this.mapObject);\n    }\n}\nGroundOverlay.decorators = [\n    { type: Directive, args: [{\n                selector: 'ngui-map > ground-overlay',\n                inputs: INPUTS$8,\n                outputs: OUTPUTS$8,\n            },] },\n];\n/**\n * @nocollapse\n */\nGroundOverlay.ctorParameters = () => [\n    { type: NguiMapComponent, },\n];\n\nconst INPUTS$9 = ['data', 'dissipating', 'gradient', 'maxIntensity', 'opacity', 'radius', 'options'];\nconst OUTPUTS$9 = [];\nclass HeatmapLayer extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n        super(nguiMapComp, 'HeatmapLayer', INPUTS$9, OUTPUTS$9);\n        this.libraryName = 'visualization';\n    }\n}\nHeatmapLayer.decorators = [\n    { type: Directive, args: [{\n                selector: 'ngui-map > heatmap-layer',\n                inputs: INPUTS$9,\n                outputs: OUTPUTS$9,\n            },] },\n];\n/**\n * @nocollapse\n */\nHeatmapLayer.ctorParameters = () => [\n    { type: NguiMapComponent, },\n];\n\nconst INPUTS$10 = ['clickable', 'preserveViewport', 'screenOverlays', 'suppressInfoWindows', 'url', 'zIndex', 'options'];\nconst OUTPUTS$10 = ['click', 'defaultviewport_changed', 'status_changed'];\nclass KmlLayer extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n        super(nguiMapComp, 'KmlLayer', INPUTS$10, OUTPUTS$10);\n    }\n}\nKmlLayer.decorators = [\n    { type: Directive, args: [{\n                selector: 'ngui-map > kml-layer',\n                inputs: INPUTS$10,\n                outputs: OUTPUTS$10,\n            },] },\n];\n/**\n * @nocollapse\n */\nKmlLayer.ctorParameters = () => [\n    { type: NguiMapComponent, },\n];\n\nconst INPUTS$11 = [\n    'anchorPoint', 'animation', 'clickable', 'cursor', 'draggable', 'icon', 'label', 'opacity',\n    'optimized', 'place', 'position', 'shape', 'title', 'visible', 'zIndex', 'options',\n    // ngui-map specific inputs\n    'geoFallbackPosition'\n];\nconst OUTPUTS$11 = [\n    'animationChanged', 'click', 'clickableChanged', 'cursorChanged', 'dblclick', 'drag', 'dragend', 'draggableChanged',\n    'dragstart', 'flatChanged', 'iconChanged', 'mousedown', 'mouseout', 'mouseover', 'mouseup', 'positionChanged', 'rightclick',\n    'shapeChanged', 'titleChanged', 'visibleChanged', 'zindexChanged'\n];\nclass Marker extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n        super(nguiMapComp, 'Marker', INPUTS$11, OUTPUTS$11);\n        this.nguiMapComp = nguiMapComp;\n        this.objectOptions = ({});\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        if (this.nguiMapComponent.mapIdledOnce) {\n            this.initialize();\n        }\n        else {\n            this.nguiMapComponent.mapReady$.subscribe(map => this.initialize());\n        }\n    }\n    /**\n     * @return {?}\n     */\n    initialize() {\n        super.initialize();\n        this.setPosition();\n    }\n    /**\n     * @return {?}\n     */\n    setPosition() {\n        if (!this['position']) {\n            this._subscriptions.push(this.nguiMapComp.geolocation.getCurrentPosition().subscribe(position => {\n                let /** @type {?} */ latLng = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);\n                this.mapObject.setPosition(latLng);\n            }, error => {\n                console.error('ngui-map, error finding the current location');\n                this.mapObject.setPosition(this.objectOptions['geoFallbackPosition'] || new google.maps.LatLng(0, 0));\n            }));\n        }\n        else if (typeof this['position'] === 'string') {\n            this._subscriptions.push(this.nguiMapComp.geoCoder.geocode({ address: this['position'] }).subscribe(results => {\n                this.mapObject.setPosition(results[0].geometry.location);\n            }, error => {\n                console.error('ngui-map, error finding the location from', this['position']);\n                this.mapObject.setPosition(this.objectOptions['geoFallbackPosition'] || new google.maps.LatLng(0, 0));\n            }));\n        }\n    }\n}\nMarker.decorators = [\n    { type: Directive, args: [{\n                selector: 'ngui-map > marker',\n                inputs: INPUTS$11,\n                outputs: OUTPUTS$11,\n            },] },\n];\n/**\n * @nocollapse\n */\nMarker.ctorParameters = () => [\n    { type: NguiMapComponent, },\n];\n\nclass PlacesAutoComplete {\n    /**\n     * @param {?} optionBuilder\n     * @param {?} elementRef\n     * @param {?} apiLoader\n     */\n    constructor(optionBuilder, elementRef, apiLoader) {\n        this.optionBuilder = optionBuilder;\n        this.elementRef = elementRef;\n        this.apiLoader = apiLoader;\n        this.place_changed = new EventEmitter();\n        this.initialized$ = new EventEmitter();\n        // only called when map is ready\n        this.initialize = () => {\n            this.objectOptions =\n                this.optionBuilder.googlizeAllInputs(['bounds', 'componentRestrictions', 'types'], this);\n            if (!google.maps.places) {\n                throw missingLibraryError('PlacesAutoComplete', 'places');\n            }\n            this.autocomplete = new google.maps.places.Autocomplete(this.elementRef.nativeElement, this.objectOptions);\n            this.autocomplete.addListener('place_changed', place => {\n                this.place_changed.emit(this.autocomplete.getPlace());\n            });\n            this.initialized$.emit(this.autocomplete);\n        };\n        apiLoader.load();\n        apiLoader.api$.subscribe(() => this.initialize());\n    }\n}\nPlacesAutoComplete.decorators = [\n    { type: Directive, args: [{\n                selector: '[places-auto-complete]'\n            },] },\n];\n/**\n * @nocollapse\n */\nPlacesAutoComplete.ctorParameters = () => [\n    { type: OptionBuilder, },\n    { type: ElementRef, },\n    { type: NgMapApiLoader, },\n];\nPlacesAutoComplete.propDecorators = {\n    'bounds': [{ type: Input, args: ['bounds',] },],\n    'componentRestrictions': [{ type: Input, args: ['componentRestrictions',] },],\n    'types': [{ type: Input, args: ['types',] },],\n    'place_changed': [{ type: Output, args: ['place_changed',] },],\n    'initialized$': [{ type: Output },],\n};\n\nconst INPUTS$12 = [\n    'clickable', 'draggable', 'editable', 'fillColor', 'fillOpacity', 'geodesic', 'paths',\n    'strokeColor', 'strokeOpacity', 'strokePosition', 'strokeWeight', 'visible', 'zIndex', 'options',\n];\nconst OUTPUTS$12 = [\n    'click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown',\n    'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick',\n];\nclass Polygon extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n        super(nguiMapComp, 'Polygon', INPUTS$12, OUTPUTS$12);\n    }\n}\nPolygon.decorators = [\n    { type: Directive, args: [{\n                selector: 'ngui-map>polygon, ngui-map>map-polygon',\n                inputs: INPUTS$12,\n                outputs: OUTPUTS$12,\n            },] },\n];\n/**\n * @nocollapse\n */\nPolygon.ctorParameters = () => [\n    { type: NguiMapComponent, },\n];\n\nconst INPUTS$13 = [\n    'clickable', 'draggable', 'editable', 'geodesic', 'icons', 'path', 'strokeColor',\n    'strokeOpacity', 'strokeWeight', 'visible', 'zIndex', 'options'\n];\nconst OUTPUTS$13 = [\n    'click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown',\n    'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'\n];\nclass Polyline extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n        super(nguiMapComp, 'Polyline', INPUTS$13, OUTPUTS$13);\n    }\n}\nPolyline.decorators = [\n    { type: Directive, args: [{\n                selector: 'ngui-map > polyline',\n                inputs: INPUTS$13,\n                outputs: OUTPUTS$13,\n            },] },\n];\n/**\n * @nocollapse\n */\nPolyline.ctorParameters = () => [\n    { type: NguiMapComponent, },\n];\n\nconst INPUTS$14 = [\n    'selector', 'options',\n    'addressControl', 'addressControlOptions', 'clickToGo', 'disableDefaultUI', 'disableDoubleClickZoom',\n    'enableCloseButton', 'fullscreenControl', 'fullscreenControlOptions', 'imageDateControl', 'linksControl',\n    'motionTracking', 'motionTrackingControl', 'panControl', 'panControlOptions', 'pano',\n    'position', 'pov', 'scrollwheel', 'showRoadLabels', 'visible', 'zoomControl', 'zoomControlOptions'\n];\nconst OUTPUTS$14 = [\n    'closeclick', 'pano_changed', 'position_changed', 'pov_changed', 'resize', 'status_changed',\n    'visible_changed', 'zoom_changed'\n];\nclass StreetViewPanorama extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n        super(nguiMapComp, 'StreetViewPanorama', INPUTS$14, OUTPUTS$14);\n    }\n    /**\n     * @return {?}\n     */\n    initialize() {\n        this.objectOptions = this.optionBuilder.googlizeAllInputs(this.inputs, this);\n        let /** @type {?} */ element;\n        if (this.objectOptions.selector) {\n            // noinspection TypeScriptValidateTypes\n            element = document.querySelector(this['selector']);\n            delete this.objectOptions.selector;\n        }\n        else {\n            element = this.nguiMapComponent.el;\n        }\n        // will be set after geocoded\n        typeof this.objectOptions.position === 'string' && (delete this.objectOptions.position);\n        this.mapObject = new google.maps[this.mapObjectName](element, this.objectOptions);\n        this.mapObject['mapObjectName'] = this.mapObjectName;\n        this.mapObject['nguiMapComponent'] = this.nguiMapComponent;\n        // set google events listeners and emits to this outputs listeners\n        this.nguiMap.setObjectEvents(this.outputs, this, 'mapObject');\n        this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n        this.initialized$.emit(this.mapObject);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this.nguiMapComponent.el) {\n            this.nguiMap.clearObjectEvents(this.outputs, this, 'mapObject');\n        }\n    }\n}\nStreetViewPanorama.decorators = [\n    { type: Directive, args: [{\n                selector: 'ngui-map > street-view-panorama',\n                inputs: INPUTS$14,\n                outputs: OUTPUTS$14,\n            },] },\n];\n/**\n * @nocollapse\n */\nStreetViewPanorama.ctorParameters = () => [\n    { type: NguiMapComponent, },\n];\n\nconst INPUTS$15 = ['autoRefresh', 'options'];\nconst OUTPUTS$15 = [];\nclass TrafficLayer extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n        super(nguiMapComp, 'TrafficLayer', INPUTS$15, OUTPUTS$15);\n    }\n}\nTrafficLayer.decorators = [\n    { type: Directive, args: [{\n                selector: 'ngui-map > traffic-layer',\n                inputs: INPUTS$15,\n                outputs: OUTPUTS$15,\n            },] },\n];\n/**\n * @nocollapse\n */\nTrafficLayer.ctorParameters = () => [\n    { type: NguiMapComponent, },\n];\n\nconst INPUTS$16 = [];\nconst OUTPUTS$16 = [];\nclass TransitLayer extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n        super(nguiMapComp, 'TransitLayer', INPUTS$16, OUTPUTS$16);\n    }\n}\nTransitLayer.decorators = [\n    { type: Directive, args: [{\n                selector: 'ngui-map > transit-layer',\n                inputs: INPUTS$16,\n                outputs: OUTPUTS$16,\n            },] },\n];\n/**\n * @nocollapse\n */\nTransitLayer.ctorParameters = () => [\n    { type: NguiMapComponent, },\n];\n\nconst COMPONENTS_DIRECTIVES = [\n    NguiMapComponent, InfoWindow,\n    Marker, Circle, CustomMarker, Polygon, InfoWindow, Polyline, GroundOverlay,\n    TransitLayer, TrafficLayer, HeatmapLayer, BicyclingLayer, KmlLayer, DataLayer,\n    StreetViewPanorama, PlacesAutoComplete, DirectionsRenderer,\n    DrawingManager,\n];\nclass NguiMapModule {\n    /**\n     * @param {?=} config\n     * @return {?}\n     */\n    static forRoot(config = {}) {\n        return {\n            ngModule: NguiMapModule,\n            providers: [\n                { provide: NG_MAP_CONFIG_TOKEN, useValue: config }\n            ],\n        };\n    }\n}\nNguiMapModule.decorators = [\n    { type: NgModule, args: [{\n                imports: [CommonModule],\n                declarations: COMPONENTS_DIRECTIVES,\n                exports: [COMPONENTS_DIRECTIVES],\n                providers: [\n                    GeoCoder,\n                    NavigatorGeolocation,\n                    NguiMap,\n                    OptionBuilder,\n                    { provide: NgMapApiLoader, useClass: NgMapAsyncCallbackApiLoader },\n                ]\n            },] },\n];\n/**\n * @nocollapse\n */\nNguiMapModule.ctorParameters = () => [];\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BicyclingLayer, NavigatorGeolocation, OptionBuilder, NG_MAP_CONFIG_TOKEN, NgMapApiLoader, NgMapAsyncApiLoader, NgMapAsyncCallbackApiLoader, NguiMapComponent, InfoWindow, CustomMarker, Circle, DataLayer, DirectionsRenderer, DrawingManager, GeoCoder, GroundOverlay, HeatmapLayer, KmlLayer, Marker, NguiMap, PlacesAutoComplete, Polygon, Polyline, StreetViewPanorama, TrafficLayer, TransitLayer, NguiMapModule, BaseMapDirective as a };\n"]}