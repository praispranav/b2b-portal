{"version":3,"sources":["c:/Users/HP/Desktop/B2B/b2b-portal/node_modules/@angular/cdk/esm2015/stepper.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqBA;;;;;;;;;;;;;;CAOC,2FAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAyGD,aAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoRD,aAMC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkCD,aASC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsBD,aASC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAcD,4LAOC","file":"stepper.js","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, TemplateRef, ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, ContentChildren, EventEmitter, ElementRef, forwardRef, Inject, Input, Optional, Output, ViewChild, ViewEncapsulation, NgModule } from '@angular/core';\nimport { FocusKeyManager } from '@angular/cdk/a11y';\nimport { Directionality, BidiModule } from '@angular/cdk/bidi';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { END, ENTER, HOME, SPACE } from '@angular/cdk/keycodes';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport '@angular/forms';\nimport { Subject, of } from 'rxjs';\nimport { startWith, takeUntil } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nclass CdkStepLabel {\n    /**\n     * @param {?} template\n     */\n    constructor(template) {\n        this.template = template;\n    }\n}\nCdkStepLabel.decorators = [\n    { type: Directive, args: [{\n                selector: '[cdkStepLabel]',\n            },] },\n];\n/** @nocollapse */\nCdkStepLabel.ctorParameters = () => [\n    { type: TemplateRef, },\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Used to generate unique ID for each stepper component.\n */\nlet /** @type {?} */ nextId = 0;\n/**\n * Change event emitted on selection changes.\n */\nclass StepperSelectionEvent {\n}\nclass CdkStep {\n    /**\n     * @param {?} _stepper\n     */\n    constructor(_stepper) {\n        this._stepper = _stepper;\n        /**\n         * Whether user has seen the expanded step content or not.\n         */\n        this.interacted = false;\n        this._editable = true;\n        this._optional = false;\n        this._customCompleted = null;\n    }\n    /**\n     * Whether the user can return to this step once it has been marked as complted.\n     * @return {?}\n     */\n    get editable() { return this._editable; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set editable(value) {\n        this._editable = coerceBooleanProperty(value);\n    }\n    /**\n     * Whether the completion of step is optional.\n     * @return {?}\n     */\n    get optional() { return this._optional; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set optional(value) {\n        this._optional = coerceBooleanProperty(value);\n    }\n    /**\n     * Whether step is marked as completed.\n     * @return {?}\n     */\n    get completed() {\n        return this._customCompleted == null ? this._defaultCompleted : this._customCompleted;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set completed(value) {\n        this._customCompleted = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n    get _defaultCompleted() {\n        return this.stepControl ? this.stepControl.valid && this.interacted : this.interacted;\n    }\n    /**\n     * Selects this step component.\n     * @return {?}\n     */\n    select() {\n        this._stepper.selected = this;\n    }\n    /**\n     * Resets the step to its initial state. Note that this includes resetting form data.\n     * @return {?}\n     */\n    reset() {\n        this.interacted = false;\n        if (this._customCompleted != null) {\n            this._customCompleted = false;\n        }\n        if (this.stepControl) {\n            this.stepControl.reset();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnChanges() {\n        // Since basically all inputs of the MatStep get proxied through the view down to the\n        // underlying MatStepHeader, we have to make sure that change detection runs correctly.\n        this._stepper._stateChanged();\n    }\n}\nCdkStep.decorators = [\n    { type: Component, args: [{selector: 'cdk-step',\n                exportAs: 'cdkStep',\n                template: '<ng-template><ng-content></ng-content></ng-template>',\n                encapsulation: ViewEncapsulation.None,\n                changeDetection: ChangeDetectionStrategy.OnPush,\n            },] },\n];\n/** @nocollapse */\nCdkStep.ctorParameters = () => [\n    { type: CdkStepper, decorators: [{ type: Inject, args: [forwardRef(() => CdkStepper),] },] },\n];\nCdkStep.propDecorators = {\n    \"stepLabel\": [{ type: ContentChild, args: [CdkStepLabel,] },],\n    \"content\": [{ type: ViewChild, args: [TemplateRef,] },],\n    \"stepControl\": [{ type: Input },],\n    \"label\": [{ type: Input },],\n    \"ariaLabel\": [{ type: Input, args: ['aria-label',] },],\n    \"ariaLabelledby\": [{ type: Input, args: ['aria-labelledby',] },],\n    \"editable\": [{ type: Input },],\n    \"optional\": [{ type: Input },],\n    \"completed\": [{ type: Input },],\n};\nclass CdkStepper {\n    /**\n     * @param {?} _dir\n     * @param {?} _changeDetectorRef\n     * @param {?=} _elementRef\n     * @param {?=} _document\n     */\n    constructor(_dir, _changeDetectorRef, _elementRef, _document) {\n        this._dir = _dir;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._elementRef = _elementRef;\n        /**\n         * Emits when the component is destroyed.\n         */\n        this._destroyed = new Subject();\n        this._linear = false;\n        this._selectedIndex = 0;\n        /**\n         * Event emitted when the selected step has changed.\n         */\n        this.selectionChange = new EventEmitter();\n        this._orientation = 'horizontal';\n        this._groupId = nextId++;\n        this._document = _document;\n    }\n    /**\n     * Whether the validity of previous steps should be checked or not.\n     * @return {?}\n     */\n    get linear() { return this._linear; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set linear(value) { this._linear = coerceBooleanProperty(value); }\n    /**\n     * The index of the selected step.\n     * @return {?}\n     */\n    get selectedIndex() { return this._selectedIndex; }\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n    set selectedIndex(index) {\n        if (this._steps) {\n            // Ensure that the index can't be out of bounds.\n            if (index < 0 || index > this._steps.length - 1) {\n                throw Error('cdkStepper: Cannot assign out-of-bounds value to `selectedIndex`.');\n            }\n            if (this._selectedIndex != index &&\n                !this._anyControlsInvalidOrPending(index) &&\n                (index >= this._selectedIndex || this._steps.toArray()[index].editable)) {\n                this._updateSelectedItemIndex(index);\n            }\n        }\n        else {\n            this._selectedIndex = index;\n        }\n    }\n    /**\n     * The step that is selected.\n     * @return {?}\n     */\n    get selected() {\n        // @breaking-change 7.0.0 Change return type to `CdkStep | undefined`.\n        return this._steps ? this._steps.toArray()[this.selectedIndex] : /** @type {?} */ ((undefined));\n    }\n    /**\n     * @param {?} step\n     * @return {?}\n     */\n    set selected(step) {\n        this.selectedIndex = this._steps ? this._steps.toArray().indexOf(step) : -1;\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        this._keyManager = new FocusKeyManager(this._stepHeader)\n            .withWrap()\n            .withVerticalOrientation(this._orientation === 'vertical');\n        (this._dir ? /** @type {?} */ (this._dir.change) : of())\n            .pipe(startWith(this._layoutDirection()), takeUntil(this._destroyed))\n            .subscribe(direction => this._keyManager.withHorizontalOrientation(direction));\n        this._keyManager.updateActiveItemIndex(this._selectedIndex);\n        this._steps.changes.pipe(takeUntil(this._destroyed)).subscribe(() => {\n            if (!this.selected) {\n                this._selectedIndex = Math.max(this._selectedIndex - 1, 0);\n            }\n        });\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    /**\n     * Selects and focuses the next step in list.\n     * @return {?}\n     */\n    next() {\n        this.selectedIndex = Math.min(this._selectedIndex + 1, this._steps.length - 1);\n    }\n    /**\n     * Selects and focuses the previous step in list.\n     * @return {?}\n     */\n    previous() {\n        this.selectedIndex = Math.max(this._selectedIndex - 1, 0);\n    }\n    /**\n     * Resets the stepper to its initial state. Note that this includes clearing form data.\n     * @return {?}\n     */\n    reset() {\n        this._updateSelectedItemIndex(0);\n        this._steps.forEach(step => step.reset());\n        this._stateChanged();\n    }\n    /**\n     * Returns a unique id for each step label element.\n     * @param {?} i\n     * @return {?}\n     */\n    _getStepLabelId(i) {\n        return `cdk-step-label-${this._groupId}-${i}`;\n    }\n    /**\n     * Returns unique id for each step content element.\n     * @param {?} i\n     * @return {?}\n     */\n    _getStepContentId(i) {\n        return `cdk-step-content-${this._groupId}-${i}`;\n    }\n    /**\n     * Marks the component to be change detected.\n     * @return {?}\n     */\n    _stateChanged() {\n        this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * Returns position state of the step with the given index.\n     * @param {?} index\n     * @return {?}\n     */\n    _getAnimationDirection(index) {\n        const /** @type {?} */ position = index - this._selectedIndex;\n        if (position < 0) {\n            return this._layoutDirection() === 'rtl' ? 'next' : 'previous';\n        }\n        else if (position > 0) {\n            return this._layoutDirection() === 'rtl' ? 'previous' : 'next';\n        }\n        return 'current';\n    }\n    /**\n     * Returns the type of icon to be displayed.\n     * @param {?} index\n     * @return {?}\n     */\n    _getIndicatorType(index) {\n        const /** @type {?} */ step = this._steps.toArray()[index];\n        if (!step.completed || this._selectedIndex == index) {\n            return 'number';\n        }\n        else {\n            return step.editable ? 'edit' : 'done';\n        }\n    }\n    /**\n     * Returns the index of the currently-focused step header.\n     * @return {?}\n     */\n    _getFocusIndex() {\n        return this._keyManager ? this._keyManager.activeItemIndex : this._selectedIndex;\n    }\n    /**\n     * @param {?} newIndex\n     * @return {?}\n     */\n    _updateSelectedItemIndex(newIndex) {\n        const /** @type {?} */ stepsArray = this._steps.toArray();\n        this.selectionChange.emit({\n            selectedIndex: newIndex,\n            previouslySelectedIndex: this._selectedIndex,\n            selectedStep: stepsArray[newIndex],\n            previouslySelectedStep: stepsArray[this._selectedIndex],\n        });\n        // If focus is inside the stepper, move it to the next header, otherwise it may become\n        // lost when the active step content is hidden. We can't be more granular with the check\n        // (e.g. checking whether focus is inside the active step), because we don't have a\n        // reference to the elements that are rendering out the content.\n        this._containsFocus() ? this._keyManager.setActiveItem(newIndex) :\n            this._keyManager.updateActiveItemIndex(newIndex);\n        this._selectedIndex = newIndex;\n        this._stateChanged();\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    _onKeydown(event) {\n        const /** @type {?} */ keyCode = event.keyCode;\n        if (this._keyManager.activeItemIndex != null && (keyCode === SPACE || keyCode === ENTER)) {\n            this.selectedIndex = this._keyManager.activeItemIndex;\n            event.preventDefault();\n        }\n        else if (keyCode === HOME) {\n            this._keyManager.setFirstItemActive();\n            event.preventDefault();\n        }\n        else if (keyCode === END) {\n            this._keyManager.setLastItemActive();\n            event.preventDefault();\n        }\n        else {\n            this._keyManager.onKeydown(event);\n        }\n    }\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n    _anyControlsInvalidOrPending(index) {\n        const /** @type {?} */ steps = this._steps.toArray();\n        steps[this._selectedIndex].interacted = true;\n        if (this._linear && index >= 0) {\n            return steps.slice(0, index).some(step => {\n                const /** @type {?} */ control = step.stepControl;\n                const /** @type {?} */ isIncomplete = control ?\n                    (control.invalid || control.pending || !step.interacted) :\n                    !step.completed;\n                return isIncomplete && !step.optional;\n            });\n        }\n        return false;\n    }\n    /**\n     * @return {?}\n     */\n    _layoutDirection() {\n        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n    }\n    /**\n     * Checks whether the stepper contains the focused element.\n     * @return {?}\n     */\n    _containsFocus() {\n        if (!this._document || !this._elementRef) {\n            return false;\n        }\n        const /** @type {?} */ stepperElement = this._elementRef.nativeElement;\n        const /** @type {?} */ focusedElement = this._document.activeElement;\n        return stepperElement === focusedElement || stepperElement.contains(focusedElement);\n    }\n}\nCdkStepper.decorators = [\n    { type: Directive, args: [{\n                selector: '[cdkStepper]',\n                exportAs: 'cdkStepper',\n            },] },\n];\n/** @nocollapse */\nCdkStepper.ctorParameters = () => [\n    { type: Directionality, decorators: [{ type: Optional },] },\n    { type: ChangeDetectorRef, },\n    { type: ElementRef, },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n];\nCdkStepper.propDecorators = {\n    \"_steps\": [{ type: ContentChildren, args: [CdkStep,] },],\n    \"linear\": [{ type: Input },],\n    \"selectedIndex\": [{ type: Input },],\n    \"selected\": [{ type: Input },],\n    \"selectionChange\": [{ type: Output },],\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Button that moves to the next step in a stepper workflow.\n */\nclass CdkStepperNext {\n    /**\n     * @param {?} _stepper\n     */\n    constructor(_stepper) {\n        this._stepper = _stepper;\n        /**\n         * Type of the next button. Defaults to \"submit\" if not specified.\n         */\n        this.type = 'submit';\n    }\n}\nCdkStepperNext.decorators = [\n    { type: Directive, args: [{\n                selector: 'button[cdkStepperNext]',\n                host: {\n                    '(click)': '_stepper.next()',\n                    '[type]': 'type',\n                }\n            },] },\n];\n/** @nocollapse */\nCdkStepperNext.ctorParameters = () => [\n    { type: CdkStepper, },\n];\nCdkStepperNext.propDecorators = {\n    \"type\": [{ type: Input },],\n};\n/**\n * Button that moves to the previous step in a stepper workflow.\n */\nclass CdkStepperPrevious {\n    /**\n     * @param {?} _stepper\n     */\n    constructor(_stepper) {\n        this._stepper = _stepper;\n        /**\n         * Type of the previous button. Defaults to \"button\" if not specified.\n         */\n        this.type = 'button';\n    }\n}\nCdkStepperPrevious.decorators = [\n    { type: Directive, args: [{\n                selector: 'button[cdkStepperPrevious]',\n                host: {\n                    '(click)': '_stepper.previous()',\n                    '[type]': 'type',\n                }\n            },] },\n];\n/** @nocollapse */\nCdkStepperPrevious.ctorParameters = () => [\n    { type: CdkStepper, },\n];\nCdkStepperPrevious.propDecorators = {\n    \"type\": [{ type: Input },],\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nclass CdkStepperModule {\n}\nCdkStepperModule.decorators = [\n    { type: NgModule, args: [{\n                imports: [BidiModule, CommonModule],\n                exports: [CdkStep, CdkStepper, CdkStepLabel, CdkStepperNext, CdkStepperPrevious],\n                declarations: [CdkStep, CdkStepper, CdkStepLabel, CdkStepperNext, CdkStepperPrevious]\n            },] },\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nexport { StepperSelectionEvent, CdkStep, CdkStepper, CdkStepLabel, CdkStepperNext, CdkStepperPrevious, CdkStepperModule };\n"]}